= Список смежности Ia
== Условие
Для каждой вершины орграфа вывести её степень.
== Код (фрагменты кода)
#set text(size: 12pt)
```rust
/// Получить степень каждой вершины орграфа
pub fn task_3_5<T: Clone + DeserializeOwned + Debug + Serialize + Default>(
    graph: &Graph<T>,
) -> Result<Vec<(u32, u32)>, Box<dyn Error>> {
    if !graph.get_is_directed() {
        return Err(Box::new(GraphError::new(
            GraphKindError::GraphMustBeDirected,
            "по условию должен быть орграф",
        )));
    }
    // Вектор пар (вершина, степень вершины)
    let mut result: Vec<(u32, u32)> = Vec::new();
    for (&node_index, adjacency) in graph {
        // заполняем вектор парами (вершина, количество ребер)
        result.push((*node_index, adjacency.len().try_into().unwrap()));
    }
    Ok(result)
}
```

#set text(size: 14pt)
== Краткое описание алгоритма
Данный алгоритм вычисляет степени всех вершин в ориентированном графе
(орграфе).

=== Что делает
+ Проверяет, что граф является ориентированным (орграфом), иначе возвращает
  ошибку
+ Перебирает все вершины и их смежности в графе
+ Формирует вектор пар (индекс_вершины, количество_исходящих_ребер) для каждой
  вершины

== Примеры входных и выходных данных

=== Входные данные
```
"2": [(7, 4), (3, 1), (5, 8), (90, 9), (2, 7)],
"3": [(7, 20), (5, 62), (2, 59)],
"4": [(2, 7)],
"5": [],
"6": [(90, 9)],
"7": [],
"8": [],
"90": [(90, 100), (5, 8), (2, 7)]
```
#image("images/01.png", height: 50%)

=== Выходные данные
```
8
Степень вершины {3} = 3
Степень вершины {4} = 1
Степень вершины {8} = 0
Степень вершины {7} = 0
Степень вершины {90} = 3
Степень вершины {2} = 5
Степень вершины {5} = 0
Степень вершины {6} = 1
```
