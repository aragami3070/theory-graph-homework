= Веса IVb
== Условие
Определить, есть ли в графе вершина, минимальные стоимости путей от которой до
остальных в сумме не превосходят $P$
== Код (фрагменты кода)
#set text(size: 12pt)
```rust
type Result<T> = std::result::Result<T, Box<dyn Error>>;
/// Находим сумму минимальных путей до всех вершин достижимых вершин из
/// вершины start
fn bellman_ford<T: Clone + DeserializeOwned + Debug + Serialize + Default>(
    graph: &Graph<T>,
    start: &Index,
) -> u32 {
    // Создаем HashMap из индекса вершины и длины пути до нее
    // (изначально максимум для u32)
    let mut dist = HashMap::new();
    for (index, _) in graph.iter() {
        dist.insert(*index, u32::MAX);
    }

    // Для вершины start длина пути 0
    dist.insert(*start, 0);

    // Перебираем все ребра
    for _ in 0..graph.len() - 1 {
        for (ind, adj) in graph.iter() {
            for edge in adj {
                let edge_node_num = edge.node.number;
                // Если вес ребра короче чем чем текущее значение в dist
                if dist[&edge_node_num] != u32::MAX
                    && dist[ind] > dist[&edge_node_num] + edge.weight
                {
                    // Обновляем значение веса для данной вершины
                    dist.insert(*ind, dist[&edge_node_num] + edge.weight);
                }
            }
        }
    }

    dist.iter()
        .filter(|&(ind, _)| ind != start) // не учитываем расстояние от start
        .map(|(_, weight)| *weight)
        .filter(|&v| v != u32::MAX) // не учитываем недостижимые
        .sum::<u32>()
}

/// Найти в [`Graph<T>`] вершину, минимальные стоимости путей от которой до
/// остальных в сумме не превосходят limit
///
/// # Errors
/// Эта функция вернет ошибку, если граф ориентированный.
/// Ошибка типа: [`GraphError`]
pub fn task_9_2<T: Clone + DeserializeOwned + Debug + Serialize + Default>(
    graph: &Graph<T>,
    limit: &u32,
) -> Result<i32> {
    if graph.get_is_directed() {
        return Err(Box::new(GraphError::new(
            GraphKindError::GraphMustBeDirected,
            "по условию должен быть неориентированный граф",
        )));
    }

    for (start, _) in graph {
        let res = bellman_ford(graph, start);
        if res > 0 && res <= *limit {
            return Ok((**start) as i32);
        }
    }

    // Вершина не найдена
    Ok(-1)
}
```

#set text(size: 14pt)
== Краткое описание алгоритма
Данный алгоритм реализует модифицированный алгоритм Беллмана-Форда для поиска
вершины с минимальной суммой кратчайших путей до всех достижимых вершин в
неориентированном графе.

=== Что делает
Находит вершину start, для которой сумма минимальных расстояний до всех
достижимых вершин $lt.eq$ limit:
- Для каждой вершины запускает Беллман-Форд
- Суммирует расстояния только до достижимых вершин (не MAX)
- Возвращает индекс первой подходящей вершины или -1

// Шаги алгоритма:
// 1. Проверка условий
//   - Работает только для неориентированных графов
//   - Возвращает ошибку для ориентированных графов
// 2. Перебор всех стартовых вершин
//   - Для каждой вершины start вызывает bellman_ford
//   - Проверяет sum ≤ limit && sum > 0
// 3. Беллман-Форд для одной стартовой вершины
//   - dist[index] = MAX для всех вершин кроме start
//   - dist[start] = 0
// 4. |V|-1 итераций релаксации
//   - Перебирает все рёбра графа
//   - Обновляет dist[u] = min(dist[u], dist[v] + weight) для каждого ребра (v,u)
// 5. Подсчет суммы расстояний
//   - Суммирует dist[i] для всех i ≠ start где dist[i] ≠ MAX
//   - Игнорирует недостижимые вершины и расстояние до самой себя
// 6. Результат
//   - Возвращает индекс первой вершины с sum ≤ limit
//   - -1, если ни одна вершина не удовлетворяет условию
== Примеры входных и выходных данных

=== Входные данные
```
```

=== Выходные данные
```
```

